<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangyuying.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="路漫漫其修远兮 吾将上下而求索">
<meta property="og:type" content="website">
<meta property="og:title" content="张玉莹的个人博客">
<meta property="og:url" content="http://zhangyuying.cn/page/8/index.html">
<meta property="og:site_name" content="张玉莹的个人博客">
<meta property="og:description" content="路漫漫其修远兮 吾将上下而求索">
<meta property="og:locale">
<meta property="article:author" content="张玉莹">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhangyuying.cn/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>

  <title>张玉莹的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张玉莹的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-readnotes">

    <a href="/readnotes/" rel="section"><i class="fa fa-calendar fa-fw"></i>readnotes</a>

  </li>
        <li class="menu-item menu-item-seriallearn">

    <a href="/seriallearn/" rel="section"><i class="fa fa-sitemap fa-fw"></i>seriallearn</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/aboutme/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AB-Java-I-O%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AB-Java-I-O%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">JAVA编程思想：十八-Java I/O系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-17 00:07:11" itemprop="dateCreated datePublished" datetime="2019-04-17T00:07:11+08:00">2019-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于程序语言的设计者来说，创建一个好的输入/输出（<code>I/O</code>）系统是一项艰难的任务</p>
<h4 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h4><p><code>File</code> 既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称（<code>File</code>是文件和目录路径名的抽象形式）</p>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/test.txt/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 可以回去文件信息：file.getName()、file.length()、file.isFile()、file.isDirectory() 等等</span></span><br><span class="line">   </span><br><span class="line">	 <span class="comment">// 创建目录</span></span><br><span class="line">     File filedir = <span class="keyword">new</span> File(<span class="string">&quot;D:/test/test&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(!filedir.exists())&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;路径不存在&quot;</span>);</span><br><span class="line">         filedir.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//可以获取目录信息：filedir.isDirectory()、filedir.isFile()、filedir.list().length等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Java</code>中，<code>File </code>类是 <code>java.io </code>包中唯一代表磁盘文件本身的对象。</p>
<p><code>File</code>类主要用来获取或处理与磁盘文件相关的信息，像文件名、 文件路径、访问权限和修改日期等，还可以浏览子目录层次结构。</p>
<p><code>File </code>类表示处理文件和文件系统的相关信息。也就是说，<code>File</code> 类不具有从文件读取信息和向文件写入信息的功能，它仅描述文件本身的属性。</p>
<h4 id="2-输入和输出"><a href="#2-输入和输出" class="headerlink" title="2.输入和输出"></a>2.输入和输出</h4><p>编程语言的<code>I/O</code>类库中常使用“流’’这个概念，它代表任何有能力产出数据的数据源对象或者有能力接收数据的接收端对象，“流”屏蔽了实际的<code>I/O</code>设备中处理数据的细节</p>
<p><code>java</code>类库中的<code>I/O</code>类分成输入和输出两部分：</p>
<ul>
<li>任何自<code>InputStrean</code>或<code>Reader</code>派生而来的类都含有名为<code>read()</code>的基本方法，用于读取单个字节或者字节数组</li>
<li>任何自<code>OutputStream</code>或<code>Writer</code>派生而来的类都含有名为<code>write()</code>的基本方法，用于写单个字节或者字节数组</li>
</ul>
<p>不过，我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供期望的功能(装饰器模式)</p>
<p><code>java</code>中“流”让人困惑的主要原因就在于：创建单一的结果流，却需要创建多个对象</p>
<p><strong><code>InputStrean</code>类型</strong></p>
<p><code>InputString</code>的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p>
<ul>
<li>子节数组（<code>ByteArrayInputStream</code>）</li>
<li><code>String</code>对象（<code>StringBufferInputStream</code>:已弃用）</li>
<li>文件（<code>FileInputStream</code>）</li>
<li>“管道”，工作方式与实际管道相似，即：从一端输入，从另一端输出（<code>PipedInputStream</code>）</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内（<code>SequenceInputStream</code>）</li>
<li>其他数据源，如<code>Internet</code>连接等</li>
</ul>
<p>每一种数据源都有相应的<code>InputStream</code>子类</p>
<p><code>FilterInputStream</code>也属于一种<code>InputStream</code>，为“装饰器”类提供基类，其中“装饰器”类可以把属性或有用的接口与输入流连接在一起</p>
<p><strong><code>OutputStream</code>类型</strong></p>
<p>该类别的类决定了输出所要去往的目标：</p>
<ul>
<li>子节数组(但不是<code>String</code>,不过可以用子节数组自己创建)（<code>ByteArrayOutputStream</code>）</li>
<li>文件（<code>FileOutputStream</code>）</li>
<li>管道（<code>PipeOutputStream</code>）</li>
</ul>
<p><code>FilterOutputStream</code>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来</p>
<h4 id="3-添加属性和有用的接口"><a href="#3-添加属性和有用的接口" class="headerlink" title="3.添加属性和有用的接口"></a>3.添加属性和有用的接口</h4><p><code>java I/O</code>需要多种不同功能的组合，这正是使用装饰器模式的理由所在</p>
<p>装饰器模式也有一个缺点：在编写程序时，他给我们提供了相当多的灵活性（因为我们可以很容易的混合和匹配属性），但是他同样也增加了代码的复杂性</p>
<p>通过<code>FilterInputStream</code>从<code>InputStream</code>读取数据：</p>
<p><code>FilterInputStream</code>类能够完成两件完全不同的事情：</p>
<ul>
<li><code>DataInputStream</code>允许我们读取不同的基本类型数据以及<code>String</code>对象(所有方法都以<code>read</code>开头，例如<code>readByte()</code>等等)，搭配相应的<code>DataOutputStream</code>,我们就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方</li>
<li>其他的<code>FilterInputStream</code>类则在内部修改<code>InputStream</code>的行为方式：是否缓冲、是否保留读过的行等等（其他的<code>FilterInputStream</code>例如：<code>BufferedInputStream</code>）</li>
</ul>
<p>通过<code>FilterOutputStream</code>向<code>OutStream</code>写入：</p>
<p><code>FilterInputStream</code>类包括：</p>
<ul>
<li><p><code>DataOutputStream</code>：与<code>DateInputStream</code>对应的是<code>DataOutputStream,</code>他可以将各种基本数据类型以及<code>String</code>对象格式化输出到“流”中，这样一来，任何机器上的<code>DataInputStream</code>都能够读取他们，所有方法都以<code>write</code>开头，例如<code>writeByte()</code>等等</p>
</li>
<li><p><code>PrintStream</code>的目的是为了格式化输出（<code>DataOutputStream</code>的目的时间数据元素置入“流”中，使<code>DateInputStream</code>能够可移植的重构他们）</p>
<p><code>PrintStream</code>是有一些问题的：一个是捕捉了所有<code>IOException</code>(因为我们必须使用<code>checkErrors</code>自行的检查错误状态)，二是为完全国际化，不能以平台无关的方式处理换行动作（这些问题在<code>printWrite</code>中得到了解决）</p>
</li>
<li><p><code>BufferedOutputStream</code>:对数据使用缓存技术，每次像流写入时，不必每次都进行实际的物理写动作，在输出时，我们可能经常使用它</p>
</li>
</ul>
<h4 id="4-Reader和Writer"><a href="#4-Reader和Writer" class="headerlink" title="4.Reader和Writer"></a>4.<code>Reader</code>和<code>Writer</code></h4><p><code>Reader</code>和<code>Writer</code>是提供兼容<code>Unicode</code>与<strong>面向字符</strong> 的<code>I/O</code>功能</p>
<p>有时候我们需要把字节流的类和字符流的类结合起来使用，为了实现这个目的，要用到适配器类：<code>InputStreamReader</code>可以把<code>InputStream</code>转换为<code>Reader</code>,而<code>OutputStreamWriter</code>可以把<code>OutputStream</code>转换为<code>Writer</code></p>
<p>设计<code>Reader</code>和<code>Writer</code>主要是为了支持国际化，之前的子节流继承结构只支持<code>8</code>位的子节流，不能很好地处理<code>16</code>位的<code>Unicode</code>字符</p>
<p>几乎所有原始的<code>java I/O</code>流类都有相应的<code>Reader</code>和<code>Writer</code>类，来提供天然的<code>Unicode</code>操作</p>
<p>但是有时我们还是需要使用字节流，例如<code>java.util.Zip</code>类库就是面向字节的而不是面向字符的，因此最明智的做法是尽量尝试使用<code>Reader</code>和<code>Writer</code>一旦代码无法成功编译，我们就知道不得不使用面向字节的类库</p>
<p>无论何时我们使用<code>readLine()</code>都不应该使用<code>DataInputStream</code>(过时方法)，而应该使用<code>BufferedReader</code>,除了这一点，<code>DataInputStream</code>仍是I/O类库的首选成员</p>
<h4 id="5-自我独立的类：RandomAccessFile"><a href="#5-自我独立的类：RandomAccessFile" class="headerlink" title="5.自我独立的类：RandomAccessFile"></a>5.自我独立的类：<code>RandomAccessFile</code></h4><p><code>RandomAccessFile</code>不是<code>InputStream</code>和<code>OutputStream</code> 继承层次结构中的一部分，除了实现了<code>DataInput</code>和<code>DateOutput</code>接口（<code>DataInputStream</code>和<code>DataOutputStream</code>也实现了这两个接口）之外，无其他关联</p>
<p><code>RandomAccessFile</code>的工作方式类似于把<code>DataInputStream</code>和<code>DataOutputStream</code>组合起来使用，还添加了一些方法：例如<code>getFilepointer()</code>(查找当前所处的文件位置)</p>
<p>只有<code>RandomAccessFile</code>支持搜寻方法，并且只适用于文件（<code>BufferedInputStream</code>能允许标注位置(<code>mark()</code>),其值存储于内部某个简单变量内）和重新设定位置(<code>reaset()</code>),这些功能很有限，不是非常有用</p>
<p>在<code>JDK1.4</code>中，<code>RandomAccessFile</code>的大多数功能（不是全部）由<code>nio</code>存储映射文件所取代</p>
<h4 id="6-I-O流的典型使用方式"><a href="#6-I-O流的典型使用方式" class="headerlink" title="6.I/O流的典型使用方式"></a>6.<code>I/O</code>流的典型使用方式</h4><ul>
<li><p>1.缓冲输入文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">in.readLine()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.从内存输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringReader in = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">&quot;Test.java&quot;</span>));</span><br><span class="line">in.read()</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.格式化的内存输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(BufferedInputFile.read(<span class="string">&quot;Test.java&quot;</span>).getBytes()));</span><br><span class="line">System.out.print(in.readByte());</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.基本的文件输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;Test.out&quot;</span>)));</span><br><span class="line">out.println(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//JAVA SE5在PrintWriter添加了一个辅助构造器，不必自己执行所有装饰工作，不过其他的常见写入任务没有快捷方式</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;Test.out&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.存储和恢复数据</p>
<p><code>PrintWriter</code>可以对数据进行格式化，以便人们的阅读，但是为了输出可供另一个“流”恢复的数据，我们需要用<code>DataOutputStream</code>写入数据，并用<code>DataInputStream</code>恢复数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">out.writeUTF(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">out.close();</span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">System.out.println(in.readUTF());</span><br></pre></td></tr></table></figure>

<p>不过，对象序列化和<code>XML</code>可能是更容易的存储和读取复杂数据结构的方式</p>
</li>
<li><p>6.读写随机访问文件</p>
<p><code>RandomAccessFile</code>中，利用<code>seek()</code>可以在文件中到处移动，并修改文件中的某个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器的第二个参数：r:只读，rw:读写</span></span><br><span class="line">RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">rf.writeUTF(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">rf.close();</span><br><span class="line">display();</span><br><span class="line">RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">rf.seek(<span class="number">5</span>*<span class="number">8</span>);<span class="comment">//double是8个字长，方法的意思是查找第五个双精度的值</span></span><br><span class="line">rf.writeDouble(<span class="string">&quot;50.0&quot;</span>);</span><br><span class="line">display();</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.管道流</p>
<p>多线程中更能体现他的价值，因为管道流用于任务之间的通信</p>
</li>
</ul>
<h4 id="7-标准I-O"><a href="#7-标准I-O" class="headerlink" title="7.标准I/O"></a>7.标准<code>I/O</code></h4><p>标准<code>I/O</code>这个术语是参照<code>Unix</code>中的“程序所使用的单一信息流”这个概念。</p>
<ul>
<li>程序的所有输入都可以来自于标准输入</li>
<li>程序的所有输出都可以发送到标准输出</li>
<li>程序的所有错误信息都可以发送到标准错误</li>
</ul>
<p>标准<code>I/O</code>的意义在于：我们可以很容易的把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入</p>
<p>按照标准<code>I/O</code>的模型，<code>java</code>提供了<code>System.in</code>、<code>System.out</code>、<code>System.err</code></p>
<ul>
<li><p><code>System.out</code>：标准输出，已经被包装成了<code>printStream</code>对象</p>
<p><code>System.out</code>可以被转化为<code>PrintWriter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器的第二个参数要设置为true,以便开启自动清空功能，否则可能看不到输出</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>System.err</code>：标准错误，已经被包装了成<code>printStream</code>对象</p>
</li>
<li><p><code>System.in</code>：标准输入，没有被包装过的，未被加工的<code>InputStream</code>。所以：我们可以立即使用<code>System.out</code>和<code>System.err</code>，但是在读取<code>System.in</code>之前必须对其进行包装，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//System.in和大多数流一样，通常应该对它进行缓冲</span></span><br><span class="line">in.readLine();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>标准<code>I/O</code>的重定向：<code>System</code>类提供了一些静态方法，允许对标准输入、输出、错误<code>I/O</code>流进行重定向</p>
<ul>
<li><code>setIn(InputStream)</code></li>
<li><code>setOut(PrintStream)</code></li>
<li><code>setErr(PrintStream)</code></li>
</ul>
<p>当输出滚动太快导致无法阅读或者想重复测试某个特定用户的输入序列的命令行程序的时候，重定向输出就显得尤为有用</p>
<p>需要注意的是：<code>I/O</code>重定向操纵的是字节流，而不是字符流。</p>
<h4 id="8-新I-O"><a href="#8-新I-O" class="headerlink" title="8.新I/O"></a>8.新<code>I/O</code></h4><p><code>JDK 1.4</code>的<code>java.nio.*</code>包中引入了新的<code>javaI/O</code>类库，其目的主要在于提高速度</p>
<p>实际上旧的<code>I/O</code>包已经使用<code>nio</code>重新实现过，以便充分的利用这种速度的提高，因此即使我们没有显示的使用<code>nio</code>编写代码，也能从其中受益</p>
<p>速度的提高在文件<code>I/O</code>和网络<code>I/O</code>中都存在，我们研究前者</p>
<p>速度的提高来自于所使用的结构更接近于操作系统执行<code>I/O</code>的方式：通道和缓冲器</p>
<p>唯一直接与通道交互的缓存器是<code>ByteBuffer</code>（也就是说：可以存储未加工字节的缓冲器）</p>
<p>旧<code>I/O</code>类库中有三个类被修改了，用以产生<code>FileChannel</code>。这三个类为：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>，注意这些是子节操作流和底层的<code>nio</code>性质一致，<code>Reader</code>和<code>Writer</code>这种字符模式类不能用于产生通道，但是<code>java.nio.channels.Channels</code>类提供了实用方法，用以在通道中产生<code>Reader</code>和<code>Writer</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>).getChannel();</span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">&quot;some String&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>通道是一种相当基础的东西：可以向它传送用于读写的<code>ByteBuffer</code>,并且可以锁定文件的某些区域用于独占式访问。</p>
<p>将字节存放于<code>ByteBuffer</code>的方法之一是：</p>
<ul>
<li>使用一种<code>“put”</code>方法直接对他们进行填充，填入一个或多个字节，或基本数据类型的值</li>
<li>使用<code>warp()</code>方法将已存在的字节数组“包装”到<code>ByteBuffer</code>中，一旦如此，就不再复制底层的数组，而是把它作为所产生的<code>ByteBuffer</code>的存储器，我们称之为数组支持的<code>ByteBuffer</code></li>
</ul>
<p>特殊方法<code>transferTo()</code>和<code>transferFrom()</code>允许我们将一个通道和另一个通道直接相连</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileChannel in = <span class="keyword">new</span> FileInputStram(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">  out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">in.transferTo(<span class="number">0</span>,in.size,out);</span><br></pre></td></tr></table></figure>

<p>转换数据：缓冲器容纳的是普通的子节，为了把它们转换城字符，我们要么在输入它们的时候对其进行编码（这样，它们输出时才具有意义），要么在将其从缓冲器输出时对他们进行解码，可以使用<code>java.nio.charset.Charset</code>类实现这些功能，该类提供了把数据编码成多种不同类型的字符集的工具</p>
<p>获取基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">bb.asLongBuffer().put(<span class="number">11111</span>);</span><br><span class="line">bb.getLong();</span><br><span class="line">bb.rewind();</span><br><span class="line">bb.asDoubleBuffer().put(<span class="number">11111</span>);</span><br><span class="line">bb.getDouble();</span><br><span class="line"><span class="comment">//向ByteBuffer插入基本类型数据的最简单的方法是：利用asCharBuffer()、asShortBuffer()等获得该缓冲器上的视图，然后使用视图的put()方法</span></span><br></pre></td></tr></table></figure>

<p>视图缓冲器：可以让我们通过某个特定的基本数据类型的视窗来查看其底层的<code>ByteBuffer</code>，<code>ByteBuffer</code>依然是实际存储数据的地方，“支持着前面的视图”，因此，对视图的任何修改都会映射成为对<code>ByteBuffer</code>中数据的修改，如上的示例</p>
<p>一旦底层的<code>ByteBuffer</code>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写道通道中了</p>
<p>字节存放次序：不同的机器可能会使用不同的字节排序方法来存储数据：</p>
<ul>
<li><code>big endian</code>：高位优先，将最重要的字节存放在地址最低的存储器单元</li>
<li><code>little endian</code>：低位优先，将最重要的字节存放在地址最高的存储器单元</li>
</ul>
<p>当存储量大于一个字节时例如<code> int</code>、<code>float</code>等，就需要考虑字节的顺序问题了</p>
<p><code>ByteBuffer</code>是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式，不过我们可以采用带有参数<code>ByteOrder.BIG_ENDIAN</code>或<code>ByteOrder.LITTLE_ENDIAN</code>的<code>order()</code>方法改变<code>ByteBuffer</code>的字节排序方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.wrap(<span class="keyword">new</span> Byte[<span class="number">12</span>]);</span><br><span class="line">bb.order(ByteOrder.BIG_ENDIAN);<span class="comment">//默认方式</span></span><br><span class="line">bb.order(ByteOrder.LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure>

<p><code>ByteBuffer</code>是将数据库移进移出通道的唯一方式，但是我们不能把基本类型的缓冲器转换为<code>ByteBuffer</code>,所以此时便可使用视图缓冲器将基本类型移进移出<code>ByteBuffer</code></p>
<p><code>Buffer</code>由数据和可以高效地访问及操纵这些数据的四个索引组成，这四个索引是：<code>mark</code>（标记）、<code>position</code>（位置）、<code>limit</code>（界限）、和<code>capacity</code>（容量）</p>
<p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化</p>
<p>内存映射文件：内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问，这种方法极大的简化了用于修改文件的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0X8FFFFF</span>;</span><br><span class="line">MappedByteBuffer out = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>).getChannel().map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,length);</span><br><span class="line">out.put((<span class="keyword">byte</span>)<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">out.get(length/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>MappedByteBuffer</code>是一种特殊类型的直接缓冲器，注意我们必须制定映射文件的初始位置和映射区域的长度，这意味着我们可以映射某个文件的较小部分</p>
<p><code>MappedByteBuffer</code>由<code>ByteBuffer</code>继承而来，因此它具有<code>ByteBuffer</code>的所有方法</p>
<p>尽管“旧”的<code>I/O</code>流在用<code>nio</code>实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度（建立映射文件的花费很大，但是整体收益比起<code>I/O</code>流来说还是很显著的）</p>
<p>文件加锁：<code>JDK1.4</code>引入了文件加锁机制，允许我们同步访问某个作为共享资源的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">FileLock fl = fos.getChannel().tryLock();</span><br></pre></td></tr></table></figure>

<p>通过对<code>FileChannel</code>调用<code>tryLock()</code>或<code>lock()</code>,就可以获得整个文件的<code>FileLock</code>：</p>
<ul>
<li><p><code>tryLock()</code>是非阻塞式的，他设法获取锁，如果不能获得，将直接从方法调用返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared);<span class="comment">//第三个参数为是否是共享锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lock()</code>是阻塞式的，他要阻塞进程直至锁可以获得，或调用<code>lock()</code>的线程中断，或调用<code>lock()</code>的通道关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, bollean shared);<span class="comment">//第三个参数为是否是共享锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>FileLock.release()</code>可以释放锁</p>
</li>
</ul>
<p>对独占锁或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么他就会使用独占锁，锁的类型(共享或独占)可以通过<code>FileLock.isShared()</code>进行查询。</p>
<h4 id="9-压缩"><a href="#9-压缩" class="headerlink" title="9.压缩"></a>9.压缩</h4><p><code>java I/O</code>类库中的类支持读写压缩格式的数据流，可以用他们对其他的<code>I/O</code>类进行封装，以提供压缩功能</p>
<p>这些类不是从<code>Reader</code>和<code>Writer</code>类派生而来，而是属于<code>InputStream</code>和<code>OutputStream</code>继承层次结构的一部分，这样做是因为压缩类库是按字节方式而不是字符方式处理的，不过有时我们可能会被迫要混合两种类型的数据流</p>
<p>尽管存在多种压缩算法：<code>GZIP</code>和<code>Zip</code>是最常用的</p>
<p>（1）使用<code>GZIP</code>进行简单压缩</p>
<p><code>GZIP</code>接口非常简单，因此如果我们要对单个数据流进行压缩，是比较合适的选择</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> GZIPOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.gz&quot;</span>)));</span><br><span class="line">out.write(...);</span><br><span class="line">BufferedReader in2 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> GZIPInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>))));</span><br><span class="line">in2.readLine();</span><br></pre></td></tr></table></figure>

<p>（2）使用<code>Zip</code>进行多文件保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.zip&quot;</span>);</span><br><span class="line">CheckOutputStream csum = <span class="keyword">new</span> CheckOutputStream(f,<span class="keyword">new</span> Adler32());</span><br><span class="line">ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">out.setComment(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>java</code>档案文件：<code>Zip</code>格式也被应用于<code>JAR</code>（<code>Java Archive</code>,<code>java</code>档案文件）文件格式中（但是<code>jar</code>工具的功能没有<code>zip</code>工具那么强大）</p>
<h4 id="10-对象序列化"><a href="#10-对象序列化" class="headerlink" title="10.对象序列化"></a>10.对象序列化</h4><p>对象在程序终止时，不会再存在。存在某些情况，若是存在在程序不运行的情况下仍能存在并保存其信息，会非常有用，对象的序列化便可以做到</p>
<p><code>java</code>的对象序列化将那些<strong>实现了<code>Serializable</code>接口</strong>的对象转换成一个字节序列并能够在以后将这个字节序列完全恢复为原来的对象</p>
<ul>
<li>这一过程甚至可以通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异</li>
<li>对象序列化可以实现轻量级持久性，“持久性“意味着一个对象的生存周期并不取决与程序是否在执行，他可以生存于程序的调用之间，通过将一个序列化对象写入磁盘，然后再重新调用程序时恢复该对象，就能实现持久性的效果</li>
</ul>
<p>对象序列化加入到语言中，是为了支持两种特性：</p>
<ul>
<li><code>java</code>的远程方法调用（<code>RMI</code>），他是存活在其他计算机上的对象就像是存活在本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值</li>
<li>对于<code>Java Beans</code>来说，对象序列化也是必需的（可能需要保留状态信息）</li>
</ul>
<p>要序列化一个对象：首先要创建某些<code>OutputStream</code>对象，然后将其封装在一个<code>ObjectOutputStream</code>对象内，这时，调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>。（对象序列化是基于字节的，因此使用<code>InputStream</code>和<code>OutputStream</code>继承结构）要反向进行该过程（即将一个序列还原为一个对象）需要将一个<code>InputStream</code>封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>。[我们获得的是一个引用，指向一个向上转型的<code>Object</code>,需要向下转型]</p>
<ul>
<li>被还原的对象确实包含了<strong>原对象中的所有连接</strong> </li>
<li>在对一个<code>Serializable</code>对象进行还原的过程中，没有调用任何构造器，包括默认的构造器，这个对象都是通过从<code>InputStream</code>中取得数据恢复而来的</li>
</ul>
<p>将一个对象从的序列化状态中恢复出来：需要必须保证<code>Java</code>虚拟机能够找到相关的<code>.class</code>文件</p>
<p>序列化的控制：可通过<code>Externalizable</code>接口代替<code>Serializable</code>接口来对对象的序列化过程进行控制，这个<code>Externalizable</code>继承了<code>Serializable</code>接口，同时新增了两个方法：<code>writeExternal()</code>和<code>readExternal()</code>。这两个方法会在序列化和反序列化还原的过程中被自动调用</p>
<ul>
<li>对于一个<code>Externalizable</code>对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化，然后调用<code>readExternal()</code>）</li>
<li>我们需要在<code>writeExternal()</code>方法（没有任何默认行为来为<code>Externalizable</code>对象写入任何成员对象）中将来自对象的重要信息写入，还必须在<code>readExternal()</code>方法中恢复数据</li>
</ul>
<p><code>transient</code>(瞬时)关键字：关闭序列化</p>
<p>不想被<code>java</code>的序列化机制自动保存与恢复的子对象，例如密码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br></pre></td></tr></table></figure>

<p>因为<code>Externalizable</code>对象在默认情况下不保存他们的任何字段，所以<code>transient</code>关键字只能和<code>Serializable</code>对象一起使用</p>
<p><code>Externalizable</code>的替代方法：如果不是特别坚持实现<code>Externalizable</code>接口，我们可以实现<code>Serializable</code>接口并添加（不是覆盖或者实现）名为<code>writeObject()</code>和<code>readObject()</code>的方法，这样一旦对象被序列化或者反序列化还原，就会自动地分别调用这两个方法，也就是说，只要我们提供这两个方法，就会使用他们而不是默认的序列化机制</p>
<p>深拷贝：我们可以通过一个字节数组来使用对象序列化，从而实现对任何可<code>Serializable</code>对象的“深度复制”（<code>deep copy</code>）——深度复制意味着我们复制的是整个对象网，而不仅仅是基本对象及其引用</p>
<ul>
<li>如果我们想保存系统状态，最安全的做法是将其作为“原子”操作进行序列化</li>
</ul>
<p>要序列化<code>static</code>值，必须要自己动手去实现：需要添加<code>serializeStaticState()</code>和<code>deserializeStaticState()</code>两个<code>static</code>方法</p>
<h4 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h4><p>对象序列化的一个重要限制是他只是<code>Java</code>的解决方案：只有<code>Java</code>程序才能反序列化这种对象，一种更具互操作的解决方案是将数据转换为<code>XML</code>格式，这可以使各种各样的平台和语言使用</p>
<h4 id="12-Preferences"><a href="#12-Preferences" class="headerlink" title="12.Preferences"></a>12.Preferences</h4><p><code>Preferences API</code>(用户偏好)与对象序列化相比，前者与对象持久性更为密切，因为他可以自动存储和读取信息，不过他只能用于小的、受限的数据集合——我们只能存储基本类型和字符串，并且每个字符串的存储长度都不能超过<code>8K</code></p>
<p><code>Preferences API</code>用于存储和读取用户偏好以及程序配置项的设置</p>
<ul>
<li>是一个键-值集合（类似映射）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Preferences prefs = Preferences.useNodeForPackage(PreferencesDemo.class);</span><br><span class="line">    prefs.put(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;Oz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Preferences API</code>对于数据的存储是利用了合适的系统资源来完成的： 例如:在<code>Windows </code>下面是使用注册表来保存这些信息，而在<code>Linux</code>下面是使用用户的<code>home</code>目录下面的一个隐藏文件来存储的。</p>
<h4 id="13-总结"><a href="#13-总结" class="headerlink" title="13.总结"></a>13.总结</h4><p><code>Java I/O</code>流类库的确能满足我们的基本需求：我们可以通过控制台、文件、内存块、甚至因特网进行读写。通过继承我们可以创建新类型的输入和输出对象。并且通过重新定义<code>toString()</code>,可以对流接受的对象类型进行简单扩充</p>
<p><strong>理解<code>I/O</code>流类库，需要先理解“装饰器”模式</strong> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/04/04/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-8-cp%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/04/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-8-cp%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-8-cp命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-04 10:59:20" itemprop="dateCreated datePublished" datetime="2019-04-04T10:59:20+08:00">2019-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cp命令用来复制文件或者目录，一般情况下，</p>
<p>shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。</p>
<p>但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 </p>
<p>cp命令是Linux系统中最常用的命令之一。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p>cp  [选项]  [-T]    源文件 目的文件</p>
<p>或：</p>
<p>cp [选项]   源   目录</p>
<p>或：</p>
<p>cp [选项]  -t  目录  源 </p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p>-a ：–archive    等于-dR –preserve=all</p>
<p>-b ：为每个已存在的目标文件创建备份，类似–backup 但不接受参数</p>
<p>-i, –interactive        覆盖前询问(使前面的 -n 选项失效)</p>
<p>-n, –no-clobber   不要覆盖已存在的文件(使前面的 -i 选项失效)</p>
<p>-f, –force        如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项)</p>
<p>-R, -r, –recursive  复制目录及目录内的所有项目</p>
<p>-H                跟随源文件中的命令行符号链接</p>
<p>-l, –link            链接文件而不复制</p>
<p>-L, –dereference   总是跟随符号链接</p>
<p>-d：等于–no-dereference –preserve=links</p>
<p>-P, –no-dereference   不跟随源文件中的符号链接</p>
<p>–preserve[=属性列表   保持指定的属性(默认：模式,所有权,时间戳)，如果 可能保持附加属性：环境、链接、xattr 等</p>
<p>-p       等于–preserve=模式,所有权,时间戳</p>
<p>–copy-contents        在递归处理时复制特殊文件内容</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-7-mv%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-7-mv%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-7-mv命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-03 13:37:30" itemprop="dateCreated datePublished" datetime="2019-04-03T13:37:30+08:00">2019-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>mv</code> 命令是<code>move</code>的缩写，可以用来移动文件或者将文件改名（<code>move (rename) files</code>），</p>
<p>是<code>Linux</code>系统下常用的命令，经常用来备份文件或者目录。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p> <code>mv</code>  [选项]  源文件或目录  目标文件或目录</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>视<code>mv</code>命令中第二个参数类型的不同（是目标文件还是目标目录），<code>mv</code> 命令将文件重命名或将其移至一个新的目录中。</p>
<ul>
<li>当第二个参数类型是文件时，<code>mv</code>命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。</li>
<li>当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，<code>mv</code>命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，<code>mv</code>先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。</li>
</ul>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p><code>-b</code> ：若需覆盖文件，则覆盖前先行备份。 </p>
<p><code>-f</code> ：<code>force</code> 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</p>
<p><code>-i</code> ：若目标文件 (<code>destination</code>) 已经存在时，就会询问是否覆盖！</p>
<p><code>-u</code> ：若目标文件已经存在，且 <code>source</code> 比较新，才会更新(<code>update</code>)</p>
<p><code>-t</code> ： <code>--target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY</code>，即指定<code>mv</code>的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）文件改名</p>
<p>默认是带有<code> -i</code> 参数，即如果<code>log2</code>已存在，则询问是否覆盖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv log1.log log2.text</span><br></pre></td></tr></table></figure>

<p>（2）文件改名，即使<code>log3.text</code>存在，也是直接覆盖掉。</p>
<p><code>log2.text</code> 的内容直接覆盖了<code>log3.text</code> 内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -f log2.text log3.text</span><br></pre></td></tr></table></figure>

<p>（3）移动文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv log1.log test1</span><br></pre></td></tr></table></figure>

<p>（4）将三个文件一起移动到某一个文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv -t test2/  log1.text log2.log log3.log</span><br><span class="line"> 或</span><br><span class="line">mv log1.text log2.log log3.log  test3/</span><br></pre></td></tr></table></figure>

<p>（5）移动当前文件夹下所有文件到上一级目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv * ../</span><br></pre></td></tr></table></figure>

<p>（6）把当前目录的一个子目录里的文件移动到另一个子目录里</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test2/*.txt test3</span><br></pre></td></tr></table></figure>

<p>（6）目录的移动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure>

<p>（7）文件被覆盖前做简单的备份，前面加参数 -b</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv log1.txt -b log2.txt</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><code>-b</code> 不接受参数，<code>mv</code>会去读取环境变量<code>VERSION_CONTROL</code>来作为备份策略。</p>
<p><code>--backup</code>该选项指定如果目标文件存在时的动作，共有四种备份策略：</p>
<p>1.<code>CONTROL=none或off</code> : 不备份。</p>
<p>2.<code>CONTROL=numbered或t</code>：数字编号的备份</p>
<p>3.<code>CONTROL=existing或nil</code>：如果存在以数字编号的备份，则继续编号备份<code>m+1...n</code>：</p>
<p>执行<code>mv</code>操作前已存在以数字编号的文件<code>log2.txt.~1~</code>，那么再次执行将产生<code>log2.txt~2~</code>，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。</p>
<p>4.<code>CONTROL=simple或never</code>：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。</p>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/10/27/2743022.html">http://www.cnblogs.com/peida/archive/2012/10/27/2743022.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-6-rmdir%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-6-rmdir%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-6-rmdir命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-03 11:31:33" itemprop="dateCreated datePublished" datetime="2019-04-03T11:31:33+08:00">2019-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>rmdir</code> 命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。删除某目录时也必须具有对父目录的写权限。</p>
<p>注意，<code>rm -r dir</code>命令可代替<code>rmdir</code>，但是有很大危险性。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p>rmdir  [选项]  文件</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p><code>-p</code> ：<code>--parents</code> 递归删除目录，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 </p>
<p><code>-v</code> ：<code>--verbose</code>  显示指令执行过程 </p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）删除一个空的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir test1</span><br></pre></td></tr></table></figure>

<p>（2）当子目录被删除后使它也成为空目录的话，则顺便一并删除 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p test2/test3</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/04/02/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-5-rm%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/02/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-5-rm%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-5-rm命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-02 20:14:51" itemprop="dateCreated datePublished" datetime="2019-04-02T20:14:51+08:00">2019-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>rm</code>  命令。该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。</p>
<p><code>rm </code>是常用的命令，也是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在<code>/</code>（根目录）下执行<code>rm * -rf</code>）。所以，我们在执行<code>rm</code>之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>rm</code>  [选项]  文件</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>删除一个目录中的一个或多个文件或目录</p>
<p>如果没有使用<code>- r</code>选项，则<code>rm</code>不会删除目录。如果使用 <code>rm</code> 来删除文件，通常仍可以将该文件恢复原状。</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p><code>-f</code>：<code>--force</code>    忽略不存在的文件，从不给出提示。</p>
<p><code>-i</code>： <code>--interactive</code> 进行交互式删除，默认就是<code>-i</code>参数</p>
<p><code>-r</code>： <code>-R</code>,<code> --recursive</code>   指示<code>rm</code>将参数中列出的全部目录和子目录均递归地删除。</p>
<p><code>-v</code>： <code>--verbose</code>    详细显示进行的步骤</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）删除文件file,系统会先询问是否删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test1.log</span><br></pre></td></tr></table></figure>

<p>（2）强制删除file，系统不在提示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f test2.log</span><br></pre></td></tr></table></figure>

<p>（3）删除任何 .log文件，删除前逐一询问确认</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -i *.log</span><br></pre></td></tr></table></figure>

<p>（4）将test2子目录已经子目录中的所有删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r test2</span><br></pre></td></tr></table></figure>

<p>（5）将test2子目录已经子目录中的所有删除，并且不用一一确认</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf test2</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/10/26/2740521.html">http://www.cnblogs.com/peida/archive/2012/10/26/2740521.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/03/19/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-4-mkdir%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/19/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-4-mkdir%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-4-mkdir命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-19 11:16:28" itemprop="dateCreated datePublished" datetime="2019-03-19T11:16:28+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>mkdir</code> 命令用来创建指定的名称的目录</p>
<p>要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>mkdir </code>  [选项]  目录</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>通过 <code>mkdir</code> 命令可以实现在指定位置创建以 <code>DirName</code>(指定的文件名)命名的文件夹或目录。</p>
<p>要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 </p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p> <code>-m</code>： <code>--mode</code> <code>=</code> 模式，设定权限&lt;模式&gt; (类似 <code>chmod</code>)，而不是 <code>rwxrwxrwx  -  umask</code></p>
<p> <code>-p</code>：<code>--parents</code> ,可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </p>
<p> <code>-v</code>： <code>--verbose</code> ,每次创建新目录都显示信息</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）创建一个目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></table></figure>

<p>（2）递归创建多个目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p test1/test2</span><br></pre></td></tr></table></figure>

<p>（3）创建权限为777的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 777 test3</span><br><span class="line">//此时test3的权限是rwxrwxrwx</span><br></pre></td></tr></table></figure>

<p>（4）创建新的目录并显示信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -v test5</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html">http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-3-pwd%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-3-pwd%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-3-pwd命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-18 16:23:43" itemprop="dateCreated datePublished" datetime="2019-03-18T16:23:43+08:00">2019-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>pwd</code> 命令来查看”当前工作目录“的完整路径。</p>
<p> 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就可以使用<code>pwd</code>来判定当前目录在文件系统内的确切位置。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>pwd</code>   [选项]</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>查看”当前工作目录“的完整路径</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p>一般情况下不带任何参数</p>
<p>如果目录是链接时：</p>
<p>格式：<code>pwd -P </code> 显示出实际路径，而非使用连接（<code>link</code>）路径。 </p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）查看当前工作目录的完整路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>（2）目录连接链接时，<code>pwd -P</code>  显示出实际路径，而非使用连接（<code>link</code>）路径；<code>pwd</code>显示的是连接路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]# cd /etc/init.d </span><br><span class="line">[root@localhost init.d]# pwd</span><br><span class="line">/etc/init.d</span><br><span class="line">[root@localhost init.d]# pwd -P</span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]#</span><br></pre></td></tr></table></figure>

<p>（3）命令：</p>
<p>​    <code>/bin/pwd</code>   [选项]</p>
<p>​    选项：</p>
<p>​    <code>-L</code> 目录连接链接时，输出连接路径</p>
<p>​    <code>-P</code> 输出物理路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost init.d]# /bin/pwd </span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]# /bin/pwd -P</span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]# /bin/pwd -L</span><br><span class="line">/etc/init.d</span><br><span class="line">[root@localhost init.d]#</span><br></pre></td></tr></table></figure>

<p>注：当前目录被删除了，而<code>pwd</code>命令仍然显示那个目录</p>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html">http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-2-cd%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-2-cd%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令-2-cd命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-18 15:32:14" itemprop="dateCreated datePublished" datetime="2019-03-18T15:32:14+08:00">2019-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>cd </code>命令可以说是<code>Linux</code>中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用<code> cd</code> 命令上的。</p>
<p>所以，学习<code>Linux</code> 常用命令，首先就要学好<code>cd</code>命令。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>cd</code>  [目录名]</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>切换当前目录至某一个目录</p>
<h4 id="3-常用示例"><a href="#3-常用示例" class="headerlink" title="3.常用示例"></a>3.常用示例</h4><p>（1）进入系统根目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /                         :直接回到根目录</span><br><span class="line">cd .. 或者 cd ..//		    :回到上一级目录</span><br><span class="line">cd ../.. // 				 :进入当前目录的父目录的父目录。</span><br></pre></td></tr></table></figure>

<p>（2）进入当前用户主目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  或者  cd ~</span><br></pre></td></tr></table></figure>

<p>（3）跳转到指定目录</p>
<p>跳转到指定目录</p>
<ul>
<li>从根目录开始，目录名称前加 <code>/</code> </li>
<li>当前目录内的子目录直接写名称即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  /opt/log</span><br></pre></td></tr></table></figure>

<p>（4）返回进入此目录之前所在的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure>

<p>（5）把上个命令的参数作为<code>cd</code>参数使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html">http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">每天一个Linux命令目录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-18 13:49:05" itemprop="dateCreated datePublished" datetime="2019-03-18T13:49:05+08:00">2019-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每天一个Linux命令的目录</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4%E7%9B%AE%E5%BD%95/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/03/10/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-1-ls%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/10/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-1-ls%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">每天一个Linux命令(1):ls命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-10 17:26:19" itemprop="dateCreated datePublished" datetime="2019-03-10T17:26:19+08:00">2019-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 11:43:01" itemprop="dateModified" datetime="2020-11-19T11:43:01+08:00">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>ls</code>命令是<code>linux</code>下最常用的命令。</p>
<ul>
<li><code>ls</code>命令就是<code>list</code>的缩写</li>
<li>缺省下<code>ls</code>用来打印出当前目录的清单，如果<code>ls</code>指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</li>
<li>通过<code>ls </code>命令不仅可以查看<code>linux</code>文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。</li>
</ul>
<p><code>ls</code> 命令在日常的<code>linux</code>操作中用的很多</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>ls</code>    [参数]    [目录名]</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>列出目标目录中所有的子目录和文件。</p>
<h4 id="3-常用参数（只列举了少数常用部分）"><a href="#3-常用参数（只列举了少数常用部分）" class="headerlink" title="3.常用参数（只列举了少数常用部分）"></a>3.常用参数（只列举了少数常用部分）</h4><p><code>-a</code> ：即<code>-all</code>,列出目录下的所有文件，包括.开头的隐藏文件</p>
<p><code>-l</code>： 除了文件名之外，还将文件的权限、所有者、文件大小等详细信息列出来   <code>ls -l</code>   <code>===</code>   <code>ll</code></p>
<p><code>-t</code>：以文件的修改时间排序</p>
<p><code>-S</code>：根据文件大小排序</p>
<p><code>-s</code>：<code>-size</code>以块大小为单位列出所有文件的大小</p>
<p><code>-R</code>：<code>–recursive</code> 同时列出所有子目录层</p>
<h4 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h4><p>（1）列出当前目录中所有以<code>“t”</code>开头的详细内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l t*</span><br></pre></td></tr></table></figure>

<p>（2）列出<code>/home/peidachang</code> 文件夹下的所有文件和目录的详细资料</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l -R /home/peidachanjavca</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2012/10/23/2734829.html">https://www.cnblogs.com/peida/archive/2012/10/23/2734829.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张玉莹"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">张玉莹</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮 吾将上下而求索</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangyuying-cn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangyuying-cn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张玉莹</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
